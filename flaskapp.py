# -*- coding: utf-8 -*-
"""FlaskApp(movie recommendation).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YJRMaTfe5Z7ptXPCulDwEkmyZzZnz1bQ
"""

!pip install flask-ngrok
!pip install tensorflow_recommenders

from flask import Flask, request, jsonify
from flask_ngrok import run_with_ngrok
import tensorflow as tf
import tensorflow_recommenders as tfrs
import pandas as pd
import numpy as np

# Load data
content_df = pd.read_csv('content_df.csv')
ratings_df = pd.read_csv('ratings_df.csv')
movies_df = pd.read_csv('movies_df.csv')

# Load model
class MovieModel(tfrs.models.Model):

    def __init__(self, unique_user_ids, unique_movie_titles, rating_weight: float, retrieval_weight: float) -> None:
        super().__init__()

        embedding_dimension = 64

        # User and movie models.
        self.movie_model = tf.keras.Sequential([
            tf.keras.layers.StringLookup(
                vocabulary=unique_movie_titles, mask_token=None),
            tf.keras.layers.Embedding(len(unique_movie_titles) + 1, embedding_dimension)
        ])
        self.user_model = tf.keras.Sequential([
            tf.keras.layers.StringLookup(
                vocabulary=unique_user_ids, mask_token=None),
            tf.keras.layers.Embedding(len(unique_user_ids) + 1, embedding_dimension)
        ])

        # A small model to take in user and movie embeddings and predict ratings.
        self.rating_model = tf.keras.Sequential([
            tf.keras.layers.Dense(256, activation="relu"),
            tf.keras.layers.Dense(128, activation="relu"),
            tf.keras.layers.Dense(1),
        ])

        # The tasks.
        self.rating_task = tfrs.tasks.Ranking(
            loss=tf.keras.losses.MeanSquaredError(),
            metrics=[tf.keras.metrics.RootMeanSquaredError()],
        )
        self.retrieval_task = tfrs.tasks.Retrieval(
            metrics=tfrs.metrics.FactorizedTopK(
                candidates=tf.data.Dataset.from_tensor_slices(unique_movie_titles).batch(128).map(self.movie_model)
            )
        )

        # The loss weights.
        self.rating_weight = rating_weight
        self.retrieval_weight = retrieval_weight

    def call(self, features):
        user_embeddings = self.user_model(features["userId"])
        movie_embeddings = self.movie_model(features["original_title"])
        rating_predictions = self.rating_model(tf.concat([user_embeddings, movie_embeddings], axis=1))
        return user_embeddings, movie_embeddings, rating_predictions

    def compute_loss(self, features, training=False):
        ratings = features.pop("rating")
        user_embeddings, movie_embeddings, rating_predictions = self(features)

        rating_loss = self.rating_task(labels=ratings, predictions=rating_predictions)
        retrieval_loss = self.retrieval_task(user_embeddings, movie_embeddings)

        return self.rating_weight * rating_loss + self.retrieval_weight * retrieval_loss

unique_user_ids = ratings_df['userId'].astype(str).unique()
unique_movie_titles = movies_df['original_title'].unique()

model = MovieModel(unique_user_ids, unique_movie_titles, rating_weight=1.0, retrieval_weight=1.0)

dummy_user = tf.constant(["dummy"])
dummy_movie = tf.constant(["dummy"])
model({"userId": dummy_user, "original_title": dummy_movie})

model.load_weights('tfrs.h5')

# Set up Flask app
app = Flask(__name__)
run_with_ngrok(app)

@app.route('/')
def home():
    return "Welcome to the Movie Recommendation System!"

@app.route('/recommend', methods=['GET'])
def recommend():
    user_id = request.args.get('user_id')
    top_n = int(request.args.get('top_n', 3))

    index = tfrs.layers.factorized_top_k.BruteForce(model.user_model)
    index.index_from_dataset(
        tf.data.Dataset.zip((tf.data.Dataset.from_tensor_slices(unique_movie_titles).batch(100), tf.data.Dataset.from_tensor_slices(unique_movie_titles).batch(100).map(model.movie_model)))
    )
    _, titles = index(tf.constant([str(user_id)]))
    recommendations = [title.decode("utf-8") for title in titles[0, :top_n].numpy()]

    return jsonify(recommendations)

@app.route('/predict_rating', methods=['GET'])
def predict_rating():
    user_id = request.args.get('user_id')
    movie_title = request.args.get('movie_title')

    user_embeddings, movie_embeddings, rating_prediction = model({
        "userId": tf.constant([str(user_id)]),
        "original_title": tf.constant([movie_title])
    })
    rating = rating_prediction.numpy()[0][0]

    return jsonify({'predicted_rating': rating})

if __name__ == '__main__':
    app.run()



